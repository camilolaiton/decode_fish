# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/03_noise.ipynb (unless otherwise specified).

__all__ = ['GammaNoise']

# Cell
from ..imports import *
from torch import nn
from torch import distributions as D
from typing import Optional, List
from ..funcs.utils import *

# Cell
class GammaNoise(nn.Module):
    """
    Generates GammaNoise noise distribution which can be used for sampling and
    calculating log probabilites.

    Theta can be learned (but not the baseline)

    Args:
        theta (Optional[float]): 1/theta gives the rate for torch.distributions.gamma
        baseline (Optional[float]): baseline (currently not used)
        n_channels (Optional[int]): Number of channels to be used

    """
    def __init__(
        self,
        theta:Optional[float] = 3.0,
        baseline:Optional[float] = 0.0,
        n_channels:Optional[int] = 0
    ):

        super().__init__()
        self.theta_scale = torch.tensor(theta)

        if n_channels < 0:
            raise ValueError("Provide the correct number of channels")

        if n_channels > 1:
            self.theta_par = torch.nn.Parameter(torch.ones(n_channels))
        else:
            self.theta_par = torch.nn.Parameter(torch.ones(1))

        self.baseline = baseline
        self.n_channels = n_channels

    def forward(self,
        x_sim: torch.Tensor,
        background: torch.Tensor,
        ch_inds:List[int]=None,
        randomize_range: List[float]=None
    ):
        """
        Calculates the concentration (mean / theta) of a Gamma distribution given
        the signal x_sim and background tensors.
        Also applies a shift and returns resulting the Gamma distribution.

        Args:
            x_sim (torch.Tensor): Tensor with to build simulation data
            represented as (Emitters, N_channels, X, Y, Z).
            background (torch.Tensor): Estimated background represented as
            (Emitters, N_channels, X, Y, Z)
            ch_inds (list): Channel indexes
            randomize_range (list): Range to sample random noise in
            an uniform distribution.

        """

        theta = (self.theta_scale.to(self.theta_par.device) * self.theta_par)

        if randomize_range is not None:
            theta = theta * torch.zeros_like(theta).uniform_(*randomize_range)

        if ch_inds is None:
            theta = theta[None,:,None,None,None]
        else:
            theta = theta[ch_inds]
            theta = theta[:,None,None,None,None]

        x_sim_background = x_sim + background
        x_sim_background.clamp_(1.0 + self.baseline)

        conc = (x_sim_background - self.baseline) / theta
        xsim_dist = D.Gamma(concentration=conc, rate=1 / theta)

        loc_trafo = [D.AffineTransform(loc=self.baseline, scale=1)]
        xsim_dist = D.TransformedDistribution(xsim_dist, loc_trafo)

        return xsim_dist
